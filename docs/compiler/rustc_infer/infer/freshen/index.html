<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Freshening is the process of replacing unknown variables with fresh types. The idea is that the type, after freshening, contains no inference variables but instead contains either a value for each variable or fresh “arbitrary” types wherever a variable would have been."><title>rustc_infer::infer::freshen - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-47e7ab555ef2818a.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="rustc_infer" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.0-nightly (58eefc33a 2023-08-24)" data-channel="nightly" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-b2d31d2efc7e9b67.css" data-theme-dark-css="dark-3388a2fb2ef8066b.css" data-theme-ayu-css="ayu-8c3c66a6cf12cb2f.css" ><script src="../../../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../../../static.files/main-ef3a2de404864b0b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-b2d31d2efc7e9b67.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-3388a2fb2ef8066b.css"><link rel="stylesheet" href="../../../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../rustc_infer/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../rustc_infer/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module freshen</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">rustc_infer</a>::<wbr><a href="../index.html">infer</a>::<wbr><a class="mod" href="#">freshen</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/rustc_infer/infer/freshen.rs.html#1-233">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Freshening is the process of replacing unknown variables with fresh types. The idea is that
the type, after freshening, contains no inference variables but instead contains either a
value for each variable or fresh “arbitrary” types wherever a variable would have been.</p>
<p>Freshening is used primarily to get a good type for inserting into a cache. The result
summarizes what the type inferencer knows “so far”. The primary place it is used right now is
in the trait matching algorithm, which needs to be able to cache whether an <code>impl</code> self type
matches some other type X – <em>without</em> affecting <code>X</code>. That means if that if the type <code>X</code> is in
fact an unbound type variable, we want the match to be regarded as ambiguous, because depending
on what type that type variable is ultimately assigned, the match may or may not succeed.</p>
<p>To handle closures, freshened types also have to contain the signature and kind of any
closure in the local inference context, as otherwise the cache key might be invalidated.
The way this is done is somewhat hacky - the closure signature is appended to the args,
as well as the closure kind “encoded” as a type. Also, special handling is needed when
the closure signature contains a reference to the original closure.</p>
<p>Note that you should be careful not to allow the output of freshening to leak to the user in
error messages or in any other form. Freshening is only really useful as an internal detail.</p>
<p>Because of the manipulation required to handle closures, doing arbitrary operations on
freshened types is not recommended. However, in addition to doing equality/hash
comparisons (for caching), it is possible to do a <code>ty::_match</code> operation between
2 freshened types - this works even with the closure encoding.</p>
<p><strong>An important detail concerning regions.</strong> The freshener also replaces <em>all</em> free regions with
’erased. The reason behind this is that, in general, we do not take region relationships into
account when making type-overloaded decisions. This is important because of the design of the
region inferencer, which is not based on unification but rather on accumulating and then
solving a set of constraints. In contrast, the type inferencer assigns a value to each type
variable only once, and it does so as soon as it can, so it is reasonable to ask what the type
inferencer knows “so far”.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.TypeFreshener.html" title="struct rustc_infer::infer::freshen::TypeFreshener">TypeFreshener</a></div></li></ul></section></div></main></body></html>