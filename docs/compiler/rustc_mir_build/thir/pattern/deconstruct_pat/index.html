<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`super::usefulness` explains most of what is happening in this file. As explained there, values and patterns are made from constructors applied to fields. This file defines a `Constructor` enum, a `Fields` struct, and various operations to manipulate them and convert them from/to patterns."><title>rustc_mir_build::thir::pattern::deconstruct_pat - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-47e7ab555ef2818a.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="rustc_mir_build" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.0-nightly (58eefc33a 2023-08-24)" data-channel="nightly" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-b2d31d2efc7e9b67.css" data-theme-dark-css="dark-3388a2fb2ef8066b.css" data-theme-ayu-css="ayu-8c3c66a6cf12cb2f.css" ><script src="../../../../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../../../../static.files/main-ef3a2de404864b0b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../../static.files/light-b2d31d2efc7e9b67.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../../static.files/dark-3388a2fb2ef8066b.css"><link rel="stylesheet" href="../../../../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../../rustc_mir_build/index.html"><img class="rust-logo" src="../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../../rustc_mir_build/index.html"><img class="rust-logo" src="../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module deconstruct_pat</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../../index.html">rustc_mir_build</a>::<wbr><a href="../../index.html">thir</a>::<wbr><a href="../index.html">pattern</a>::<wbr><a class="mod" href="#">deconstruct_pat</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../../src/rustc_mir_build/thir/pattern/deconstruct_pat.rs.html#1-1693">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><a href="../usefulness/index.html" title="mod rustc_mir_build::thir::pattern::usefulness"><code>super::usefulness</code></a> explains most of what is happening in this file. As explained there,
values and patterns are made from constructors applied to fields. This file defines a
<code>Constructor</code> enum, a <code>Fields</code> struct, and various operations to manipulate them and convert
them from/to patterns.</p>
<p>Thereâ€™s one idea that is not detailed in <a href="../usefulness/index.html" title="mod rustc_mir_build::thir::pattern::usefulness"><code>super::usefulness</code></a> because the details are not
needed there: <em>constructor splitting</em>.</p>
<h2 id="constructor-splitting"><a href="#constructor-splitting">Constructor splitting</a></h2>
<p>The idea is as follows: given a constructor <code>c</code> and a matrix, we want to specialize in turn
with all the value constructors that are covered by <code>c</code>, and compute usefulness for each.
Instead of listing all those constructors (which is intractable), we group those value
constructors together as much as possible. Example:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">â“˜</a><pre class="rust rust-example-rendered"><code><span class="kw">match </span>(<span class="number">0</span>, <span class="bool-val">false</span>) {
    (<span class="number">0 </span>..=<span class="number">100</span>, <span class="bool-val">true</span>) =&gt; {} <span class="comment">// `p_1`
    </span>(<span class="number">50</span>..=<span class="number">150</span>, <span class="bool-val">false</span>) =&gt; {} <span class="comment">// `p_2`
    </span>(<span class="number">0 </span>..=<span class="number">200</span>, <span class="kw">_</span>) =&gt; {} <span class="comment">// `q`
</span>}</code></pre></div>
<p>The naive approach would try all numbers in the range <code>0..=200</code>. But we can be a lot more
clever: <code>0</code> and <code>1</code> for example will match the exact same rows, and return equivalent
witnesses. In fact all of <code>0..50</code> would. We can thus restrict our exploration to 4
constructors: <code>0..50</code>, <code>50..=100</code>, <code>101..=150</code> and <code>151..=200</code>. That is enough and infinitely
more tractable.</p>
<p>We capture this idea in a function <code>split(p_1 ... p_n, c)</code> which returns a list of constructors
<code>c'</code> covered by <code>c</code>. Given such a <code>c'</code>, we require that all value ctors <code>c''</code> covered by <code>c'</code>
return an equivalent set of witnesses after specializing and computing usefulness.
In the example above, witnesses for specializing by <code>c''</code> covered by <code>0..50</code> will only differ
in their first element.</p>
<p>We usually also ask that the <code>c'</code> together cover all of the original <code>c</code>. However we allow
skipping some constructors as long as it doesnâ€™t change whether the resulting list of witnesses
is empty of not. We use this in the wildcard <code>_</code> case.</p>
<p>Splitting is implemented in the <a href="enum.Constructor.html#method.split" title="method rustc_mir_build::thir::pattern::deconstruct_pat::Constructor::split"><code>Constructor::split</code></a> function. We donâ€™t do splitting for
or-patterns; instead we just try the alternatives one-by-one. For details on splitting
wildcards, see <a href="struct.SplitWildcard.html" title="struct rustc_mir_build::thir::pattern::deconstruct_pat::SplitWildcard"><code>SplitWildcard</code></a>; for integer ranges, see <a href="struct.SplitIntRange.html" title="struct rustc_mir_build::thir::pattern::deconstruct_pat::SplitIntRange"><code>SplitIntRange</code></a>; for slices, see
<a href="struct.SplitVarLenSlice.html" title="struct rustc_mir_build::thir::pattern::deconstruct_pat::SplitVarLenSlice"><code>SplitVarLenSlice</code></a>.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.DeconstructedPat.html" title="struct rustc_mir_build::thir::pattern::deconstruct_pat::DeconstructedPat">DeconstructedPat</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Values and patterns can be represented as a constructor applied to some fields. This represents
a pattern in this form.
This also keeps track of whether the pattern has been found reachable during analysis. For this
reason we should be careful not to clone patterns for which we care about that. Use
<code>clone_and_forget_reachability</code> if youâ€™re sure.</div></li><li><div class="item-name"><a class="struct" href="struct.Fields.html" title="struct rustc_mir_build::thir::pattern::deconstruct_pat::Fields">Fields</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">A value can be decomposed into a constructor applied to some fields. This struct represents
those fields, generalized to allow patterns in each field. See also <code>Constructor</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.IntRange.html" title="struct rustc_mir_build::thir::pattern::deconstruct_pat::IntRange">IntRange</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">An inclusive interval, used for precise integer exhaustiveness checking.
<code>IntRange</code>s always store a contiguous range. This means that values are
encoded such that <code>0</code> encodes the minimum value for the integer,
regardless of the signedness.
For example, the pattern <code>-128..=127i8</code> is encoded as <code>0..=255</code>.
This makes comparisons and arithmetic on interval endpoints much more
straightforward. See <code>signed_bias</code> for details.</div></li><li><div class="item-name"><a class="struct" href="struct.Slice.html" title="struct rustc_mir_build::thir::pattern::deconstruct_pat::Slice">Slice</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">A constructor for array and slice patterns.</div></li><li><div class="item-name"><a class="struct" href="struct.SplitIntRange.html" title="struct rustc_mir_build::thir::pattern::deconstruct_pat::SplitIntRange">SplitIntRange</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">A range of integers that is partitioned into disjoint subranges. This does constructor
splitting for integer ranges as explained at the top of the file.</div></li><li><div class="item-name"><a class="struct" href="struct.SplitVarLenSlice.html" title="struct rustc_mir_build::thir::pattern::deconstruct_pat::SplitVarLenSlice">SplitVarLenSlice</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">This computes constructor splitting for variable-length slices, as explained at the top of the
file.</div></li><li><div class="item-name"><a class="struct" href="struct.SplitWildcard.html" title="struct rustc_mir_build::thir::pattern::deconstruct_pat::SplitWildcard">SplitWildcard</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">A wildcard constructor that we split relative to the constructors in the matrix, as explained
at the top of the file.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Constructor.html" title="enum rustc_mir_build::thir::pattern::deconstruct_pat::Constructor">Constructor</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">A value can be decomposed into a constructor applied to some fields. This struct represents
the constructor. See also <code>Fields</code>.</div></li><li><div class="item-name"><a class="enum" href="enum.IntBorder.html" title="enum rustc_mir_build::thir::pattern::deconstruct_pat::IntBorder">IntBorder</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Represents a border between 2 integers. Because the intervals spanning borders must be able to
cover every integer, we need to be able to represent 2^128 + 1 such borders.</div></li><li><div class="item-name"><a class="enum" href="enum.SliceKind.html" title="enum rustc_mir_build::thir::pattern::deconstruct_pat::SliceKind">SliceKind</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.expand_or_pat.html" title="fn rustc_mir_build::thir::pattern::deconstruct_pat::expand_or_pat">expand_or_pat</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Recursively expand this pattern into its subpatterns. Only useful for or-patterns.</div></li></ul></section></div></main></body></html>